// Given a component used in a collaboration type, return the assembly entries that should be
// merged into the containing collaboration type in place of the component.
PROCEDURE aggregateUpdatesGenerator(collaborationTypeName String, taskName String)

log.info("generator: beginning generating for task: {} in {}.", [taskName, collaborationTypeName])

SELECT ONE FROM collaborationtypes AS collaborationType WHERE name == collaborationTypeName AND ars_namespace == Context.namespace()
var componentInstance = collaborationType.assembly[taskName]
componentInstance.name = taskName
// We need to apply enableBadging to all tasks in this component assembly
componentInstance.configuration.enableBadging = !collaborationType.disableBadging || componentInstance.configuration.enableTaskBadging
var componentConfig = componentInstance.configuration

log.info("generator: component instance from app {}", [componentInstance.toString()])

// fetch the component definition
var componentDef = AppGeneration.getComponent(componentInstance.pattern)
log.info("generator: found component definition: {}", [ componentDef ])

// apply defaults and check for required parameters
var config = componentInstance.configuration
config = AppGeneration.validateComponentConfiguration(config, componentDef)

//
// CUSTOM CODE FOR AGGREGATE UPDATES
//
var typeDef = Utils.getType(config.typeName)

config.groupByClause = "event."

if (typeDef.groupBy) {
    config.groupByClause += typeDef.groupBy
} else if (typeDef.naturalKey) {
    config.groupByClause += typeDef.naturalKey[0]
} else {
    exception("AggregateUpdates.invalid.type", "Type {0} does not have a group by or natural key", [config.typeName])
}

//
// END CUSTOM CODE
//

var assembly = componentDef.assembly

assembly = AppGeneration.toggleBadging(assembly, componentInstance.configuration.enableBadging)

// perform basic variable substitutions from config into assembly
assembly = generateResource(assembly, config)

log.info("generator: Final assembly {}", [assembly])

return assembly